#ifndef ANALYTIC_ANALYTIC_HPP_
#define ANALYTIC_ANALYTIC_HPP_

#include <string>
#include <map>
#include <vector>
#include <opencv2/core/core.hpp>
#include "FrameGrabber.h"
#include "Result_t.hpp"
#include "ResultsQueue.hpp"

namespace analytic {
namespace api {

class Analytic
{
public:
	/*
	 * Default constructor
	 */
	Analytic(){}

	/* Function : init(...)
	 *
	 * Purpose: This method must load configuration files and initialize
	 * FrameGrabber objects. Any other initializations necessary for successful
	 * execution of the analytic library must be performed here.This method
	 * will be called before the process() method.
	 *
	 * Input mConfigFiles :  A reference to a map of configuration files in the
	 *  format of OpenCV FileStorage objects. Keys = name of a file which must
	 *  be a name returned by the function getInputFileList().
	 *
	 *  Input mFrameGrabbers : A reference to a map of FrameGrabber objects.
	 *  Key = name of an input video stream which must be a name returned by
	 *  the function getInputStreamNames().
	 *
	 *  Return value: True is returned if initializing the analytic plugin is
	 *  successful. False is returned otherwise.
	 */
	virtual bool init(const std::map<string,FileStorage>& mConfigFiles,
			          const std::map<string,FrameGrabber*>& mFrameGrabbers) = 0;
	

	/* Function : process(...)
	 *
	 * Purpose: Processing of video frames obtained from FrameGrabber objects
	 * must be done here. This method must include some form of a loop in order
	 * to continuously process video frames. For more information refer to the
	 * code fragments given in comments after the process() method signature.
	 *
	 * Input sResultsDir : One analytic result instance may consists of one or
	 * more text files in formats such as .txt, .xml, .yml, .json etc. Also a
	 * result instance may consists of one or more image files and video files.
	 * All these text, image and video files must be saved to the path
	 * provided in sResultsDir. If necessary create sub-directories inside
	 * the directory whose path is specified by sResultsDir to save the results
	 *  files. Set absolute paths of all files generated by a result in a new
	 *  Results_t object and push each Results_t object into pOutputQueue
	 *
	 * Output pOutputQueue : A shared queue between OpenCCTV platform and the
	 * analytic. Push all Results_t objects created for results produced by the
	 * analytic to the queue instance provided by pOutputQueue.
	 */
	virtual void process(const std::string& sResultsDir,
			             analytic::api::ResultsQueue<analytic::api::Result_t*>& pOutputQueue) = 0;

	/*{
		bool bEnabled = true;

		while(bEnabled)
		{
			//Process image frames
			//....................

			//For each instance of analytic result create a new object
			//of Results_t
			analytic::api::Results_t* pResult = new analytic::api::Results_t();

			//Save the results files(xml, yml, txt, etc), image files and video
			//files produced by a result to sResultsDir and set the absolute
			//path of each file in the Results_t object
			//
			//Example: Assume that related to one result an analytic produced
			//resultFile1.yml, imgFile1.jpg, imgFile2.jpg and vidFile1.avi
			//files, then given below is a possible pseudo-code
			//....................

			std::string resultFile1AbsPath = sResultsDir;
			resultFile1AbsPath.append("resultFile1.yml");
			//Save resultFile1.yml to resultFile1AbsPath
			//Add resultFile1AbsPath to Results_t object
			pResult->setResultsFile(resultFile1AbsPath);

			std::string imgFile1AbsPath = sResultsDir;
			imgFile1AbsPath.append("imgFile1.jpg");
			//Save imgFile1.jpg to imgFile1AbsPath
			//Add imgFile1AbsPath to Results_t object
			pResult->setImageFile(imgFile1AbsPath);

			std::string imgFile2AbsPath = sResultsDir;
			imgFile2AbsPath.append("imgFile2.jpg");
			//Save imgFile2.jpg to imgFile2AbsPath
			//Add imgFile2AbsPath to Results_t object
			pResult->setImageFile(imgFile2AbsPath);

			std::string vidFile1AbsPath = sResultsDir;
			vidFile1AbsPath.append("vidFile1.avi");
			//Save vidFile1.avi to vidFile1AbsPath
			//Add vidFile1AbsPath to Results_t object
			pResult->setVideoFile(vidFile1AbsPath);

			//Set the timestamp of Results_t object
			pResult->setTimestamp("PutEventTimeHere");

			//Set the custom text of Results_t object if required
			pResult->setCustomTextResult("Test Result 1");

			//Finally insert Results_t object into the pOutputQueue
			pOutputQueue.push(pResult);
		}
	}*/

	/* Function : getInputStreamNames(...)
	 *
	 * Purpose: Return a list of input video streams used by an analytic library
	 * Given below is a sample implementation for an analytic library which is
	 * using a two input stream named "Default" and "HD". Override to suit a
	 * specific analytic library. Typically an analytic library must have at
	 * least one input stream. But, In case no input streams are used return:
	 * <inputstreams></inputstreams>
	 *
	 * Return value: An XML fragment containing the details of input streams
	 * formatted as name, required(required = true, optional = false) and
	 * description elements.
	 */
	virtual std::string getInputStreamNames()
	{
		return generateInputStreamNamesXml();
	}

	/* Function : getInputFileList(...)
	 *
	 * Purpose: Return a list of input files required to initialize an
	 * analytic library. Override to suit a specific analytic library.
	 * Given below is a sample implementation for an analytic library which is
	 * using a single input file called "config.yml". In case no input files
	 * are used return:
	 * <inputfiles></inputfiles>
	 *
	 * Return value: An XML fragment containing the details of input files
	 * formatted as name, required(required = true, optional = false) and
	 * description elements.
	 */
	virtual std::string getInputFileList()
	{
		return generateInputFileListXml();
	}

	/*
	 * Destructor
	 */
	virtual ~Analytic(){}

private:
	/*
	 * Remove this function if not used by an analytic library
	 */
	std::string generateInputStreamNamesXml()
	{
		/* Sample XML stream:
		<inputstreams>
			<input>
				<name>Default</name>
				<required>true</required>
				<description>
					The default input stream used by this analytic. Minimum resolution
					should be 1280×720.
				</description>
			</input>

			<input>
				<name>HD</name>
				<required>false</required>
				<description>
					Optional high resolution input stream used to obtain snapshots in case
					an event is detected by the analytic. Minimum resolution should be
					1920x1080.
				</description>
			</input>
		</inputstreams>
	 */

		std::string sXml = "<inputstreams>";
		//Stream 1:
		sXml.append("<input>");
		sXml.append("<name>Default</name>");
		sXml.append("<required>true</required>");
		sXml.append("<description>");
		sXml.append("The default input stream used by this analytic. Minimum resolution "
					"should be 1280×720.");
		sXml.append("</description>");
		sXml.append("</input>");
		//Stream 2:
		sXml.append("<input>");
		sXml.append("<<name>HD</name>");
		sXml.append("<required>false</required>");
		sXml.append("<description>");
		sXml.append("Optional high resolution input stream used to obtain snapshots in case "
					"an event is detected by the analytic. Minimum resolution should be 1920x1080.");
		sXml.append("</description>");
		sXml.append("</input>");

		sXml.append("</inputstreams>");
		return sXml;
	}

	/*
	 * Remove this function if not used by an analytic library
	 */
	std::string generateInputFileListXml()
	{
		/* Sample XML stream:
			<inputfiles>
				<inputfile>
					<name>Configuration file</name>
					<required>true</required>
					<description>
						Include configuration details for the analytic
						library formatted as a YML file.
					</description>
				</inputfile>
			</inputfiles>
		 */

		std::string sXml = "<inputfiles>";

		//Input file 1:
		sXml.append("<inputfile>");
		sXml.append("<name>config.yml</name>");
		sXml.append("<required>true</required>");
		sXml.append("<description>");
		sXml.append("Include configuration details for the analytic library ");
		sXml.append("formatted as a YML file.");
		sXml.append("</description>");
		sXml.append("</inputfile>");

		sXml.append("</inputfiles>");
		return sXml;
	}
};

} /* namespace api */
} /* namespace analytic */

#endif /* ANALYTIC_ANALYTIC_HPP_ */

/*
 * In YOUR_ANALYTIC_CLASS.hpp include these two functions.
 *
extern "C" YOUR_ANALYTIC_CLASS* create()
{
    return new YOUR_ANALYTIC_CLASS();
}

extern "C" void destroy(YOUR_ANALYTIC_CLASS* p)
{
    if(p) {
    	delete p; p = NULL;
    }
}
*/
